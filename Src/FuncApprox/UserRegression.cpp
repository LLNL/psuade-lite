// ************************************************************************
// Copyright (c) 2007   Lawrence Livermore National Security, LLC.
// Produced at the Lawrence Livermore National Laboratory.
// Written by the PSUADE team.
// All rights reserved.
//
// Please see the COPYRIGHT_and_LICENSE file for the copyright notice,
// disclaimer, contact information and the GNU Lesser General Public License.
//
// PSUADE is free software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License (as published by the Free Software
// Foundation) version 2.1 dated February 1999.
//
// PSUADE is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the terms and conditions of the GNU General
// Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
// ************************************************************************
// Functions for the class UserRegression
// AUTHOR : CHARLES TONG
// DATE   : 2010
// ************************************************************************
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include "Psuade.h"
#include "UserRegression.h"
#include "sysdef.h"
#include "PsuadeUtil.h"
#include "PrintingTS.h"

#define PABS(x) (((x) > 0.0) ? (x) : -(x))

extern "C" {
   void dgesvd_(char *, char *, int *, int *, double *, int *, double *,
               double *, int *, double *, int *, double *, int *, int *);
}

// ************************************************************************
// Constructor 
// ------------------------------------------------------------------------
UserRegression::UserRegression(int nInputs,int nSamples):
                               FuncApprox(nInputs,nSamples)
{
  int  ii;
  char response[501], inLine[501], pString[501];
  FILE *fp;

  // display banner and additonal information
  printAsterisks(PL_INFO, 0);
  printf("*                User Regression Analysis\n");
  printf("* R-square gives a measure of the goodness of the model.\n");
  printf("* R-square should be close to 1 if it is a good model.\n");
  printf("* Turn on rs_expert mode to select input scaling.\n");
  printf("* Option to use a ps_user_regr_info file to feed information\n");
  printf("* Turn on rs_expert mode to skip regression analysis.\n");
  printf("* Create ps_user_regr_info file to set information.\n");
  printEquals(PL_INFO, 0);

  faID_ = PSUADE_RS_REGRU;
  numArgs_ = 2;
  strcpy(auxArg_, "");
  strcpy(regFile_, "");
  fp = fopen("ps_user_regr_info", "r");
  if (fp == NULL)
  {
    printf("UserRegression: this regression method needs 3 pieces of\n");
    printf("                 information from you:\n");
    printf("  (1) number of basis functions in your regression (M).\n");
    printf("  (2) a user-generated executable file which evaluates\n");
    printf("      the basis functions given any set of sample points.\n");
    printf("      This file (say user.py) will be called via:\n\n");
    printf("          user.py paramfile outputfile \n\n");
    printf("       where param_file (generated by PSUADE) has the format: \n");
    printf("       line 1: <N sample points> <number of inputs m>\n");
    printf("       line 2: 1 followed by input values for sample point 1\n");
    printf("       line 3: 2 followed by input values for sample point 2\n");
    printf("       .....\n");
    printf("       Outputfile (created by user.py) should have this format:\n");
    printf("       line 1: 1 <M basis functions evaluated for sample 1> \n");
    printf("       line 2: 2 <M basis functions evaluated for sample 2> \n");
    printf("       .....\n");
    printf("  (3) auxiliary argument (e.g. selection for multi-output)\n");
    printf("      PSUADE will call the user executable via: \n");
    printf("           <executable> <inputfile> <outputfile> <aux arg>\n"); 
    sprintf(pString, "Enter number of basis function : ");
    numTerms_ = getInt(1,10000,pString);
    sprintf(pString, "Enter name of user-generated executable file : ");
    getString(pString, regFile_);
    ii = strlen(regFile_);
    regFile_[ii-1] = '\0';
    sprintf(pString, "Any auxiliary argument? (y or n) ");
    getString(pString, response);
    if (response[0] == 'y') 
    {
      sprintf(pString, "Enter argument (in one contiguous string) : ");
      getString(pString, auxArg_);
      numArgs_++;
    }
  }
  else
  {
    printf("UserRegression information file - ps_user_regr_info found.\n");
    fscanf(fp, "%d", &numTerms_);
    if (numTerms_ <= 0)
    {
      printf("UserRegression ERROR: numTerms should be > 0.\n");
      exit(1);
    }
    printf("UserRegression number of basis function = %d\n",numTerms_);
    fscanf(fp, "%s", regFile_);
    if (fscanf(fp, "%s", auxArg_) == EOF) strcpy(auxArg_, "");;
    fclose(fp);
    printf("UserRegression user-generated executable file = %s\n",regFile_);
  }
  fp = fopen(regFile_, "r");
  if (fp == NULL)
  {
    printf("UserRegression ERROR: user-generated executable %s not found.\n",
           regFile_);
    exit(1);
  }
  fclose(fp);
 
  noAnalysis_ = 0;
  if (numTerms_ == 1 && psRSExpertMode_ == 1)
  {
    printf("UserRegression: Since number of terms = 1, regression\n");
    printf("    analysis to estimate the basis function coefficients\n");
    printf("    may not be needed. Should we go ahead with regression\n");
    printf("    analysis (least-squares) to compute coefficients? (y or n) ");
    scanf("%s", response);
    fgets(inLine, 500, stdin);
    if (response[0] != 'y') noAnalysis_ = 1;
  }

  XNShift_.setLength(nInputs_);
  XNScale_.setLength(nInputs_);
  XScales_ = new int[nInputs_];
  checkAllocate(XScales_, "XScales_ in UserRegression::constructor");
  for (ii = 0; ii < nInputs_; ii++)
  {
    XNShift_[ii]  = 0.0; 
    XNScale_[ii] = 1.0; 
    XScales_[ii] = 0; 
  }
  if (noAnalysis_ == 0 && psRSExpertMode_ == 1)
  {
    printf("Perform input scaling ? (y or n) ");
    scanf("%s", response);
    fgets(inLine, 500, stdin);
    if (response[0] == 'y') 
    {
      printf("Select the type of scaling for each input.\n");
      printf("Available ones are: \n");
      printf("0. no scaling\n");
      printf("1. scale only (i.e. X' = X * scale)\n");
      printf("2. shift and scale (X' = (X - lower bound) * scale)\n");
      for (ii = 0; ii < nInputs_; ii++)
      {
        sprintf(pString,"Choose scaling type (0, 1 or 2) for input %d : ",
                ii+1);
        XScales_[ii] = getInt(0,2,pString);
      }
    }
  }

  fp = fopen(regFile_, "r");
  if (fp == NULL)
  {
    printf("UserRegression ERROR: user executable file not found.\n");
    printf("  This file is to be used for evaluating the basis functions\n");
    printf("  given any set of sample points. This file (say user.py) \n");
    printf("  will be called via:\n\n");
    printf("        user.py paramfile outputfile \n\n");
    printf("  where param_file (generated by PSUADE) has the format: \n");
    printf("  line 1: <N sample points> <number of inputs m>\n");
    printf("  line 2: 1 followed by input values for sample point 1\n");
    printf("  line 3: 2 followed by input values for sample point 2\n");
    printf("  .....\n");
    printf("  Outputfile (created by user.py) should have this format: \n");
    printf("  line 1: calculated values for M basis functions of sample 1\n");
    printf("  line 2: calculated values for M basis functions of sample 2\n");
    printf("  .....\n");
    exit(1);
  }
  fclose(fp);
  struct stat sb;
  if (stat(regFile_, &sb) != 0 || !(sb.st_mode & S_IXUSR))
  {
    printf("UserRegression WARNING : User-generated executable file does\n");
    printf("                         not have execute permission.\n");
  }

  coefTerms_ = NULL;
}

// ************************************************************************
// destructor
// ------------------------------------------------------------------------
UserRegression::~UserRegression()
{
  if (coefTerms_ != NULL)
  {
    for (int ii = 0; ii < numTerms_; ii++)
      if (coefTerms_[ii] != NULL) delete [] coefTerms_[ii];
    delete [] coefTerms_;
  }
}

// ************************************************************************
// initialize
// ------------------------------------------------------------------------
int UserRegression::initialize(double *X, double *Y)
{
  int    ii, status;
  double lb, ub, hx;
 
  status = 0;
  if (lowerBounds_ == NULL || upperBounds_ == NULL) status = 1;
  if (status == 0)
  {
    for (ii = 0; ii < nInputs_; ii++)
      if (lowerBounds_[ii] >= upperBounds_[ii]) status = 1; 
  }
  if (status == 1)
  {
    printf("UserRegression::initialize ERROR - bounds have not been\n");
    printf("                initialized.\n");
    return 0;
  }
 
  if (coefTerms_ != NULL)
  {
    for (ii = 0; ii < numTerms_; ii++)
      if (coefTerms_[ii] != NULL) delete [] coefTerms_[ii];
    delete [] coefTerms_;
    coefTerms_ = NULL;
  }

  if (noAnalysis_ != 0)
  {
    regCoeffs_.setLength(1);
    regCoeffs_[0] = 1.0;
  }
  else
  {
    for (ii = 0; ii < nInputs_; ii++)
    {
      lb = lowerBounds_[ii];
      ub = upperBounds_[ii];
      hx = 1.0 / (ub - lb);
      if (XScales_[ii] == 1)
      {
        XNShift_[ii]  = 0.0;
        if      (lb < 0 && ub <= 0) XNScale_[ii] = - 1.0 / lb;
        else if (lb >= 0 && ub > 0) XNScale_[ii] = 1.0 / ub;
        else
        {
          hx = - lb;
          if (ub > lb) hx = ub;
          XNScale_[ii] = 1.0 / hx;
        }
      }
      else if (XScales_[ii] == 2)
      {
        if (lb < 0 && ub <= 0)
        {
          XNShift_[ii]  = ub;
          XNScale_[ii] = hx;
        }
        else 
        {
          XNShift_[ii]  = lb;
          XNScale_[ii] = hx;
        }
      }
      lb = XNShift_[ii];
      hx = XNScale_[ii]; 
      printf("Input %3d : shift = %e, scale = %e\n", ii+1,lb,hx);
    }
    status = analyze(X, Y);
    if (status != 0)
    {
      printf("UserRegression::initialize - ERROR detected.\n");
      return -1;
    }
  }
  return 0;
}

// ************************************************************************
// Generate lattice data based on the input set
// ------------------------------------------------------------------------
int UserRegression::genNDGridData(double *X, double *Y, int *N2,
                                 double **X2, double **Y2)
{
  int totPts, ss;

  if (initialize(X,Y) != 0)
  {
    printf("UserRegression::genNDGridData - ERROR detected.\n");
    (*N2) = 0;
    return -1;
  }

  if ((*N2) == -999) return 0;

  genNDGrid(N2, X2);
  if ((*N2) <= 0) return 0;
  totPts = (*N2);

  (*Y2) = new double[totPts];
  checkAllocate(*Y2, "Y2 in UserRegression::genNDGridData");
  for (ss = 0; ss < totPts; ss++)
    (*Y2)[ss] = evaluatePoint(&((*X2)[ss*nInputs_]));

  return 0;
}

// ************************************************************************
// Generate 1D mesh results (set all other inputs to nominal values)
// ------------------------------------------------------------------------
int UserRegression::gen1DGridData(double *X, double *Y, int ind1,
                                  double *settings, int *NN, 
                                  double **XX, double **YY)
{
  int    totPts, mm, nn;
  double HX, *Xloc;

  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen1DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  totPts = nPtsPerDim_;
  HX = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 

  (*NN) = totPts;
  (*XX) = new double[totPts];
  (*YY) = new double[totPts];
  Xloc  = new double[totPts*nInputs_];
  checkAllocate(Xloc, "Xloc in UserRegression::gen1DGridData");
  for (mm = 0; mm < nPtsPerDim_; mm++) 
    for (nn = 0; nn < nInputs_; nn++) 
       Xloc[mm*nInputs_+nn] = settings[nn]; 
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    Xloc[mm*nInputs_+ind1] = HX * mm + lowerBounds_[ind1];
    (*XX)[mm] = Xloc[mm*nInputs_+ind1];
  }
  evaluatePoint(totPts,Xloc,*YY);

  delete [] Xloc;
  return 0;
}

// ************************************************************************
// Generate 2D mesh results (set all other inputs to nominal values)
// ------------------------------------------------------------------------
int UserRegression::gen2DGridData(double *X, double *Y, int ind1,
                        int ind2, double *settings, int *NN, 
                        double **XX, double **YY)
{
  int    totPts, mm, nn, kk, index;
  double *HX, *Xloc;

  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen2DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  totPts = nPtsPerDim_ * nPtsPerDim_;
  HX    = new double[2];
  HX[0] = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 
  HX[1] = (upperBounds_[ind2] - lowerBounds_[ind2]) / (nPtsPerDim_ - 1); 

  (*NN) = totPts;
  (*XX) = new double[totPts * 2];
  (*YY) = new double[totPts];
  Xloc  = new double[totPts*nInputs_];
  checkAllocate(Xloc, "Xloc in UserRegression::gen2DGridData");
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++) 
    {
      index = mm * nPtsPerDim_ + nn;
      for (kk = 0; kk < nInputs_; kk++) 
        Xloc[index*nInputs_+kk] = settings[kk]; 
    }
  }
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      index = mm * nPtsPerDim_ + nn;
      Xloc[index*nInputs_+ind1] = HX[0] * mm + lowerBounds_[ind1];
      Xloc[index*nInputs_+ind2] = HX[1] * nn + lowerBounds_[ind2];
      (*XX)[index*2]   = Xloc[index*nInputs_+ind1];
      (*XX)[index*2+1] = Xloc[index*nInputs_+ind2];
    }
  }
  evaluatePoint(totPts,Xloc,*YY);

  delete [] Xloc;
  delete [] HX;
  return 0;
}

// ************************************************************************
// Generate 3D mesh results (setting others to some nominal values) 
// ------------------------------------------------------------------------
int UserRegression::gen3DGridData(double *X, double *Y, int ind1,
                                  int ind2, int ind3, double *settings, 
                                  int *NN, double **XX, double **YY)
{
  int    totPts, mm, nn, pp, kk, index;
  double *HX, *Xloc;

  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen3DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  totPts = nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_;
  HX    = new double[3];
  HX[0] = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 
  HX[1] = (upperBounds_[ind2] - lowerBounds_[ind2]) / (nPtsPerDim_ - 1); 
  HX[2] = (upperBounds_[ind3] - lowerBounds_[ind3]) / (nPtsPerDim_ - 1); 

  (*NN) = totPts;
  (*XX) = new double[totPts * 3];
  (*YY) = new double[totPts];
  Xloc  = new double[totPts*nInputs_];
  checkAllocate(Xloc, "Xloc in UserRegression::gen3DGridData");
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        index = mm * nPtsPerDim_ * nPtsPerDim_ + nn * nPtsPerDim_ + pp;
        for (kk = 0; kk < nInputs_; kk++)
          Xloc[index*nInputs_+kk] = settings[kk];
      }
    }
  }
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        index = mm * nPtsPerDim_ * nPtsPerDim_ + nn * nPtsPerDim_ + pp;
        Xloc[index*nInputs_+ind1] = HX[0] * mm + lowerBounds_[ind1];
        Xloc[index*nInputs_+ind2] = HX[1] * nn + lowerBounds_[ind2];
        Xloc[index*nInputs_+ind3] = HX[2] * pp + lowerBounds_[ind3];
        (*XX)[index*3]   = Xloc[index*nInputs_+ind1];
        (*XX)[index*3+1] = Xloc[index*nInputs_+ind2];
        (*XX)[index*3+2] = Xloc[index*nInputs_+ind3];
      }
    }
  }
  evaluatePoint(totPts,Xloc,*YY);

  delete [] Xloc;
  delete [] HX;
  return 0;
}

// ************************************************************************
// Generate 4D mesh results (setting others to some nominal values) 
// ------------------------------------------------------------------------
int UserRegression::gen4DGridData(double *X, double *Y, int ind1, int ind2,
                                  int ind3, int ind4, double *settings, 
                                  int *NN, double **XX, double **YY)
{
  int    totPts, mm, nn, pp, qq, index;
  double *HX, *Xloc;

  if (initialize(X, Y) != 0)
  {
    printf("UserRegression::gen4DGridData - ERROR detected.\n");
    (*NN) = 0;
    return -1;
  }

  totPts = nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_ * nPtsPerDim_;
  HX    = new double[4];
  HX[0] = (upperBounds_[ind1] - lowerBounds_[ind1]) / (nPtsPerDim_ - 1); 
  HX[1] = (upperBounds_[ind2] - lowerBounds_[ind2]) / (nPtsPerDim_ - 1); 
  HX[2] = (upperBounds_[ind3] - lowerBounds_[ind3]) / (nPtsPerDim_ - 1); 
  HX[3] = (upperBounds_[ind4] - lowerBounds_[ind4]) / (nPtsPerDim_ - 1); 

  (*NN) = totPts;
  (*XX) = new double[totPts * 4];
  (*YY) = new double[totPts];
  Xloc  = new double[nInputs_];
  checkAllocate(Xloc, "Xloc in UserRegression::gen4DGridData");
  for (nn = 0; nn < nInputs_; nn++) Xloc[nn] = settings[nn]; 
    
  for (mm = 0; mm < nPtsPerDim_; mm++) 
  {
    for (nn = 0; nn < nPtsPerDim_; nn++)
    {
      for (pp = 0; pp < nPtsPerDim_; pp++)
      {
        for (qq = 0; qq < nPtsPerDim_; qq++)
        {
          index = mm*nPtsPerDim_*nPtsPerDim_*nPtsPerDim_ +
                  nn*nPtsPerDim_*nPtsPerDim_ + pp * nPtsPerDim_ + qq;
          Xloc[ind1] = HX[0] * mm + lowerBounds_[ind1];
          Xloc[ind2] = HX[1] * nn + lowerBounds_[ind2];
          Xloc[ind3] = HX[2] * pp + lowerBounds_[ind3];
          Xloc[ind4] = HX[3] * qq + lowerBounds_[ind4];
          (*XX)[index*4]   = Xloc[ind1];
          (*XX)[index*4+1] = Xloc[ind2];
          (*XX)[index*4+2] = Xloc[ind3];
          (*XX)[index*4+3] = Xloc[ind4];
          (*YY)[index] = evaluatePoint(Xloc);
        }
      }
    }
  }

  delete [] Xloc;
  delete [] HX;
  return 0;
}

// ************************************************************************
// Evaluate a given point
// ------------------------------------------------------------------------
double UserRegression::evaluatePoint(double *X)
{
  int    iOne=1;
  double Y;
  evaluatePoint(iOne, X, &Y);
  return Y;
}

// ************************************************************************
// Evaluate a number of points
// ------------------------------------------------------------------------
double UserRegression::evaluatePoint(int npts, double *X, double *Y)
{
  int    ii, ind, kk;
  double Yt, ddata;
  char   sysCmd[500], lineIn[5001];
  FILE   *fp;

  if (regCoeffs_.length() <= 0)
  {
    printf("UserRegression ERROR: need to call initialize first.\n");
    return 0.0;
  }

  fp = fopen("ps_input", "w");
  if (fp == NULL)
  {
    printf("fopen returned NULL in file %s line %d, exiting\n",
           __FILE__, __LINE__);
    exit(1);
  }
  fprintf(fp, "%d %d\n", npts, nInputs_);
  for (kk = 0; kk < npts; kk++)
  {
    fprintf(fp, "%d", kk+1);
    for (ii = 0; ii < nInputs_; ii++)
    {
      ddata = (X[kk*nInputs_+ii] - XNShift_[ii]) * XNScale_[ii];
      fprintf(fp, " %24.16e", ddata);
    }
    fprintf(fp, "\n");
  }
  fprintf(fp, "\n");
  fclose(fp);
  if (outputLevel_ > 2) 
    printOutTS(PL_INFO,"Evaluating basis function with user regressor...\n");
  if (numArgs_ == 2) 
  {
    if (psPythonOverride_ == 0)
    {
      if (psPythonInterpreter_ != NULL)
      {
        sprintf(sysCmd,"%s %s ps_input ps_output",psPythonInterpreter_,
                regFile_);
      }
      else sprintf(sysCmd,"python %s ps_input ps_output", regFile_);
    }
    else sprintf(sysCmd,"%s ps_input ps_output", regFile_);
  }
  else
  {
    if (psPythonOverride_ == 0)
    {
      if (psPythonInterpreter_ != NULL)
      {
        sprintf(sysCmd,"%s %s ps_input ps_output %s",psPythonInterpreter_,
                regFile_,auxArg_);
      }
      else sprintf(sysCmd,"python %s ps_input ps_output %s",regFile_,auxArg_);
    }
    else sprintf(sysCmd,"%s ps_input ps_output %s", regFile_,auxArg_);
  }
  if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
  system(sysCmd);
  if (outputLevel_ > 2) 
    printOutTS(PL_INFO, "Basis function evaluation completed.\n");
 
  fp = fopen("ps_output", "r");
  if (fp == NULL)
  {
    printf("fopen returned NULL in file %s line %d, exiting\n",
           __FILE__, __LINE__);
     exit(1);
  }
  for (kk = 0; kk < npts; kk++)
  {
    if (kk == 0)
    {
      fscanf(fp, "%s", lineIn); 
      if (lineIn[0] == '#')
      {
        fgets(lineIn, 5000, fp);
        fscanf(fp, "%d", &ind);
      }
      else sscanf(lineIn, "%d", &ind);
    }
    else fscanf(fp, "%d", &ind);
    if (ind != kk+1)
    {
      printf("ERROR: user output file does not have correct format.\n");
      printf("  Expected index = %d, actual index = %d\n",kk+1,ind);
      fclose(fp);
      exit(1);
    }
    Yt = 0.0;
    for (ii = 0; ii < numTerms_; ii++)
    {
      fscanf(fp, "%lg", &ddata);
      Yt += regCoeffs_[ii] * ddata;
    }
    if (fgets(lineIn, 5000, fp) == NULL && kk < npts-1)
    {
      printf("ERROR: user output file does not have enough data (%d).\n",
             kk);
      fclose(fp);
      exit(1);
    }
    Y[kk] = Yt;
  }
  fclose(fp);
  unlink("ps_input");
  unlink("ps_output");
  return 0.0;
}

// ************************************************************************
// Evaluate a given point and also its standard deviation
// ------------------------------------------------------------------------
double UserRegression::evaluatePointFuzzy(double *X, double &std)
{
   int    iOne=1;
   double Y, ddata;
   evaluatePointFuzzy(iOne, X, &Y, &ddata);
   std = ddata;
   return Y;
}

// ************************************************************************
// Evaluate a number of points and also their standard deviations
// ------------------------------------------------------------------------
double UserRegression::evaluatePointFuzzy(int npts, double *X, double *Y,
                                          double *Ystd)
{
  int    ii, jj, kk;
  double *Xs, std, ddata, mean, dtmp;
  char   sysCmd[500], lineIn[5001];
  FILE   *fp;

  if (regCoeffs_.length() <= 0)
  {
    printf("UserRegression ERROR: need to call initialize first.\n");
    return 0.0;
  }

  if (noAnalysis_ == 1)
  {
    evaluatePoint(npts, X, Y);
    for (kk = 0; kk < npts; kk++) Ystd[kk] = 0.0;
  }
  else
  {
    fp = fopen("ps_input", "w");
    if (fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
    }
    fprintf(fp, "%d %d\n", npts, nInputs_);
    for (kk = 0; kk < npts; kk++)
    {
      fprintf(fp, "%d", kk+1);
      for (ii = 0; ii < nInputs_; ii++)
      {
        ddata = (X[kk*nInputs_+ii] - XNShift_[ii]) * XNScale_[ii];
        fprintf(fp, " %24.16e", ddata);
      }
      fprintf(fp, "\n");
    }
    fprintf(fp, "\n");
    fclose(fp);

    if (numArgs_ == 2) 
    {
      if (psPythonOverride_ == 0)
      {
        if (psPythonInterpreter_ != NULL)
        {
          sprintf(sysCmd,"%s %s ps_input ps_output",psPythonInterpreter_,
                  regFile_);
        }
        else sprintf(sysCmd,"python %s ps_input ps_output",regFile_);
      }
      else sprintf(sysCmd,"%s ps_input ps_output", regFile_);
    }
    else
    {
      if (psPythonOverride_ == 0)
      {
        if (psPythonInterpreter_ != NULL)
        {
          sprintf(sysCmd,"%s %s ps_input ps_output %s",
                  psPythonInterpreter_,regFile_,auxArg_);
        }
        else 
          sprintf(sysCmd,"python %s ps_input ps_output %s",regFile_,
                  auxArg_);
      }
      else sprintf(sysCmd,"%s ps_input ps_output %s", regFile_,auxArg_);
    }
    if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
    system(sysCmd);
 
    fp = fopen("ps_output", "r");
    if (fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
    }
    Xs = new double[numTerms_];
    checkAllocate(Xs, "Xs in UserRegression::evaluatePointFuzzy");
    for (kk = 0; kk < npts; kk++)
    {
      if (kk == 0)
      {
        fscanf(fp, "%s", lineIn); 
        if (lineIn[0] == '#')
        {
          fgets(lineIn, 5000, fp);
          fscanf(fp, "%d", &ii);
        }
        else sscanf(lineIn, "%d", &ii);
      }
      else fscanf(fp, "%d", &ii);
      if (ii != kk+1)
      {
        printf("ERROR: user output file does not have correct format.\n");
        printf("  Expected index = %d, actual index = %d\n",kk+1,ii);
        fclose(fp);
        exit(1);
      }
      for (ii = 0; ii < numTerms_; ii++) fscanf(fp, "%lg", &Xs[ii]);
      if (fgets(lineIn, 5000, fp) == NULL && kk < npts-1)
      {
        printf("ERROR: user output file does not have enough data (%d).\n",
               kk);
        fclose(fp);
        exit(1);
      }
      mean = 0.0;
      for (ii = 0; ii < numTerms_; ii++) mean += regCoeffs_[ii] * Xs[ii];
      Y[kk] = mean;
      std = 0.0;
      for (ii = 0; ii < numTerms_; ii++)
      {
        dtmp = 0.0;
        for (jj = 0; jj < numTerms_; jj++)
          dtmp += invCovMat_.getEntry(ii,jj) * Xs[jj];
        std += dtmp * Xs[ii];
      }
      Ystd[kk] = sqrt(std);
    }
    fclose(fp);
    unlink("ps_input");
    unlink("ps_output");
    delete [] Xs;
  }
  return 0.0;
}

// ************************************************************************
// perform regression analysis
// ------------------------------------------------------------------------
int UserRegression::analyze(double *Xin, double *Y)
{
  psVector VecX, VecY;
  VecX.load(nSamples_*nInputs_, Xin);
  VecY.load(nSamples_, Y);
  return analyze(VecX, VecY);
}

// ************************************************************************
// perform regression analysis
// ------------------------------------------------------------------------
int UserRegression::analyze(psVector VecX, psVector VecY)
{
  int    N, M, mm, nn, wlen, info, NRevised;
  double SSresid, SStotal, R2, var, esum, ymax, *arrayXX, *UU, *VV;
  char   pString[100];
  FILE   *fp;
  psMatrix eigMatT, MatXX, MatA;
  psVector eigVals;

  if (nSamples_ <= numTerms_)
  {
    printf("UserRegression::analyze ERROR - sample size too small.\n");
    return -1;
  } 
   
  N = loadXMatrix(VecX, MatXX);
  M = nSamples_;

  psVector VecA;
  VecA.setLength(M*N);
  arrayXX = MatXX.getMatrix1D();
  for (mm = 0; mm < M; mm++)
    for (nn = 0; nn < N; nn++)
      VecA[mm+nn*M] = sqrt(weights_[mm]) * arrayXX[mm+nn*M];
  MatA.load(M, N, VecA.getDVector());

  if (psMasterMode_ == 1)
  {
    fp = fopen("user_regression_matrix.m", "w");
    if(fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
             __FILE__, __LINE__);
      exit(1);
    }
    fprintf(fp, "%% the sample matrix where svd is computed\n");
    fprintf(fp, "%% the last column is the right hand side\n");
    fprintf(fp, "%% B is the vector of coefficients\n");
    fprintf(fp, "AA = [\n");
    for (mm = 0; mm < M; mm++)
    {
      for (nn = 0; nn < N; nn++)
        fprintf(fp, "%24.16e ", VecA[mm+nn*M]);
      fprintf(fp, "%24.16e \n",VecY[mm]);
    }
    fprintf(fp, "];\n");
    fprintf(fp, "A = AA(:,1:%d);\n", N);
    fprintf(fp, "Y = AA(:,%d);\n", N+1);
    fprintf(fp, "B = A \\ Y;\n");
    fclose(fp);
    printf("Regression matrix written to user_regression_matrix.m\n");
  }

  psMatrix MatU, MatV;
  psVector VecS;
  if (outputLevel_ > 3) printf("Running SVD ...\n");
  info = MatA.computeSVD(MatU, VecS, MatV);
  if (outputLevel_ > 3) 
    printf("SVD completed: status = %d (should be 0).\n",info);

  if (info != 0)
  {
    printf("* UserRegression Info: dgesvd returns a nonzero (%d).\n",info);
    printf("* UserRegression terminates further processing.\n");
    return -1;
  }

  mm = 0;
  for (nn = 0; nn < N; nn++) if (VecS[nn] < 0) mm++;
  if (mm > 0)
  {
    printf("* UserRegression WARNING: some of the singular values\n");
    printf("*            are < 0. May spell trouble but will\n");
    printf("*            proceed anyway (%d).\n",mm);
  }
  if (VecS[0] == 0.0) NRevised = 0;
  else
  {
    NRevised = N;
    for (nn = 1; nn < N; nn++)
      if (VecS[nn-1] > 0 && VecS[nn]/VecS[nn-1] < 1.0e-8) NRevised--;
  }
  if (NRevised < N)
  {
    printf("* UserRegression ERROR: true rank of sample = %d (need %d)\n",
           NRevised, N);
    return -1;
  }
  if (psMasterMode_ == 1)
  {
    printf("UserRegression: matrix singular values \n");
    printf("The VERY small ones may cause poor numerical accuracy,\n");
    printf("but not keeping them may ruin the approximation power.\n");
    printf("So, select them judiciously.\n");
    for (nn = 0; nn < N; nn++)
      printf("Singular value %5d = %e\n", nn+1, VecS[nn]);
    sprintf(pString, "How many to keep (1 - %d, 0 - all) ? ", N);
    NRevised = getInt(0,N,pString);
    if (NRevised == 0) NRevised = N;
    for (nn = NRevised; nn < N; nn++) VecS[nn] = 0.0;
  }
  else
  {
    NRevised = N;
    for (nn = 1; nn < N; nn++)
    {
      if (VecS[nn-1] > 0.0 && VecS[nn]/VecS[nn-1] < 1.0e-8)
      {
        VecS[nn] = 0.0;
        NRevised--;
      }
    }
  }

  psVector VecW, VecB;
  VecW.setLength(M+N);
  UU = MatU.getMatrix1D();
  for (mm = 0; mm < NRevised; mm++)
  {
    VecW[mm] = 0.0;
    for (nn = 0; nn < M; nn++)
      VecW[mm] += UU[nn+mm*M] * sqrt(weights_[nn]) * VecY[nn];
  }
  for (nn = 0; nn < NRevised; nn++) VecW[nn] /= VecS[nn];
  for (nn = NRevised; nn < N; nn++) VecW[nn] = 0.0;
  VecB.setLength(N);
  VV = MatV.getMatrix1D();
  for (mm = 0; mm < N; mm++)
  {
    VecB[mm] = 0.0;
    for (nn = 0; nn < NRevised; nn++) VecB[mm] += VV[nn+mm*N] * VecW[nn];
  }

  eigMatT.load(N, N, VV);
  eigVals.load(N, VecS.getDVector());
  for (nn = 0; nn < N; nn++) eigVals[nn] = pow(eigVals[nn], 2.0);

  if (psMasterMode_ == 1)
  {
    fp = fopen("user_regression_error.m", "w");
    if(fp == NULL)
    {
      printf("fopen returned NULL in file %s line %d, exiting\n",
            __FILE__, __LINE__);
      exit(1);
    }
    fprintf(fp, "%% This file contains errors of each data point.\n");
  }
  else fp = NULL;

  esum = ymax = 0.0;
  for (mm = 0; mm < nSamples_; mm++)
  {
    VecW[mm] = 0.0;
    for (nn = 0; nn < N; nn++)
      VecW[mm] = VecW[mm] + arrayXX[mm+nn*nSamples_] * VecB[nn];
    VecW[mm] = VecW[mm] - VecY[mm];
    esum = esum + VecW[mm] * VecW[mm] * weights_[mm];
    if (fp != NULL) 
      fprintf(fp, "%6d %24.16e\n",mm+1,VecW[mm]*sqrt(weights_[mm]));
    if (PABS(VecY[mm]) > ymax) ymax = PABS(VecY[mm]);
  }
  esum /= (double) nSamples_;
  esum = sqrt(esum);
  printAsterisks(PL_INFO, 0);
  printf("*            User Regression Analysis Statistics\n");
  printEquals(PL_INFO, 0);
  printf("* UserRegression:: LS mean error = %11.4e (max=%11.4e)\n",
         esum, ymax); 

  if (fp != NULL)
  {
    fclose(fp);
    printf("FILE user_regression_error.m contains data errors.\n");
  }

  computeSS(MatXX, VecY, VecB, SSresid, SStotal);
  if (SStotal == 0.0) R2 = 1.0;
  else                R2  = 1.0 - SSresid / SStotal;
  if (nSamples_ > N) var = SSresid / (double) (nSamples_ - N);
  else               var = 0.0;
  if (var < 0)
  { 
    if (PABS(var) > 1.0e-12)
    {
      printf("UserRegression WARNING: variance < 0.\n");
      printf("    Temporarily absolutize var (may have problems).\n");
      var = PABS(var); 
    }
    else var = 0;
  }
  regCoeffs_.load(VecB);

  psVector VecBstd;
  VecBstd.setLength(N);
  computeCoeffVariance(eigMatT, eigVals, var);
  for (mm = 0; mm < N; mm++)
    VecBstd[mm] = sqrt(invCovMat_.getEntry(mm,mm));

  if (outputLevel_ >= 0)
  {
    printRC(VecB, VecBstd, MatXX, VecY);
    printf("* UserRegression model R-square = %12.4e\n", R2);
    printf("* adjusted   R-square = %12.4e\n",
           1.0 - (1.0 - R2) * ((M - 1) / (M - N - 1)));
     printEquals(PL_INFO, 0);
  }

  fp = NULL;
  if (psRSCodeGen_ == 1) fp = fopen("psuade_rs.info", "w");
  if (fp != NULL)
  {
    fprintf(fp,"/* *******************************************/\n");
    fprintf(fp,"/* User regression interpolator form PSUADE. */\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"/* This file contains information for interpolation\n");
    fprintf(fp,"   using response surface. Follow the steps below:\n");
    fprintf(fp,"   1. move this file to *.c file (e.g. main.c)\n");
    fprintf(fp,"   2. Modify the main.c program\n");
    fprintf(fp,"      a. replace func with your user-defined function\n");
    fprintf(fp,"   3. Compile main.c (cc -o main main.c -lm) \n");
    fprintf(fp,"   4. run: main input output\n");
    fprintf(fp,"          where input has the number of inputs and\n");
    fprintf(fp,"          the input values\n");
    fprintf(fp,"*/\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"#include <math.h>\n");
    fprintf(fp,"#include <stdlib.h>\n");
    fprintf(fp,"#include <stdio.h>\n");
    fprintf(fp,"int interpolate(int,double*,double*,double*);\n");
    fprintf(fp,"main(int argc, char **argv) {\n");
    fprintf(fp,"  int    i, iOne=1, nInps;\n");
    fprintf(fp,"  double X[%d], Y, S;\n",nInputs_);
    fprintf(fp,"  FILE   *fIn=NULL, *fOut=NULL;\n");
    fprintf(fp,"  if (argc != 3) {\n");
    fprintf(fp,"     printf(\"ERROR: not enough argument.\\n\");\n");
    fprintf(fp,"     exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  fIn = fopen(argv[1], \"r\");\n");
    fprintf(fp,"  if (fIn == NULL) {\n");
    fprintf(fp,"     printf(\"ERROR: cannot open input file.\\n\");\n");
    fprintf(fp,"     exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  fscanf(fIn, \"%%d\", &nInps);\n");
    fprintf(fp,"  if (nInps != %d) {\n", nInputs_);
    fprintf(fp,"    printf(\"ERROR - wrong nInputs.\\n\");\n");
    fprintf(fp,"    exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  for (i=0; i<%d; i++) fscanf(fIn, \"%%lg\", &X[i]);\n",
            nInputs_);
    fprintf(fp,"  fclose(fIn);\n");
    fprintf(fp,"  interpolate(iOne, X, &Y, &S);\n");
    fprintf(fp,"  printf(\"Y = %%e\\n\", Y);\n");
    fprintf(fp,"  printf(\"S = %%e\\n\", S);\n");
    fprintf(fp,"  fOut = fopen(argv[2], \"w\");\n");
    fprintf(fp,"  if (fOut == NULL) {\n");
    fprintf(fp,"     printf(\"ERROR: cannot open output file.\\n\");\n");
    fprintf(fp,"     exit(1);\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  fprintf(fOut,\" %%e\\n\", Y);\n");
    fprintf(fp,"  fclose(fOut);\n");
    fprintf(fp,"}\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"/* Regression interpolation function         */\n");
    fprintf(fp,"/* X[0], X[1],   .. X[m-1]   - first point\n");
    fprintf(fp," * X[m], X[m+1], .. X[2*m-1] - second point\n");
    fprintf(fp," * ... */\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"static double\n");
    fprintf(fp,"regCoefs[%d] = \n", N);
    fprintf(fp,"{\n");
    for (mm = 0; mm < N; mm++)
      fprintf(fp," %24.16e,\n", regCoeffs_[mm]);
    fprintf(fp,"};\n");
    fprintf(fp,"static double\n");
    fprintf(fp,"XStat[%d][2] = \n", nInputs_);
    fprintf(fp,"{\n");
    for (mm = 0; mm < nInputs_; mm++)
      fprintf(fp,"  { %24.16e , %24.16e},\n",XNShift_[mm],XNScale_[mm]);
    fprintf(fp,"};\n");
    fprintf(fp,"static double invCovMat[%d][%d] = \n", N, N);
    fprintf(fp,"{\n");
    for (mm = 0; mm < N; mm++)
    {
      fprintf(fp," { %24.16e", invCovMat_.getEntry(mm,0));
      for (nn = 1; nn < N; nn++)
        fprintf(fp,", %24.16e", invCovMat_.getEntry(mm,nn));
      fprintf(fp," },\n");
    }
    fprintf(fp,"};\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"int func(int nInps, double *X, double *Y);\n");
    fprintf(fp,"int interpolate(int npts,double *X,double *Y,double *S){\n");
    fprintf(fp,"  int    kk, ii, jj, nInps=%d;\n",nInputs_);
    fprintf(fp,"  int    nterms=%d;\n",numTerms_);
    fprintf(fp,"  double y, *x, *u, *yy, std, dtmp;\n");
    fprintf(fp,"  u = (double *) malloc(%d *sizeof(double));\n",numTerms_);
    fprintf(fp,"  x = (double *) malloc(nInps*sizeof(double));\n");
    fprintf(fp,"  for (ii = 0; ii < npts; ii++) {\n");
    fprintf(fp,"    for (jj = 0; jj < nInps; jj++)\n");
    fprintf(fp,"      x[jj] = (X[ii*nInps+jj]-XStat[jj][0])/XStat[jj][1];\n");
    fprintf(fp,"    func(nInps,x,u);\n");
    fprintf(fp,"    y = 0.0;\n");
    fprintf(fp,"    for (jj = 0; jj < nterms; jj++)\n");
    fprintf(fp,"      y += regCoefs[jj] * u[jj];\n");
    fprintf(fp,"    Y[ii] = y * %e + %e;\n", YStd_, YMean_);
    fprintf(fp,"    std = 0.0;\n");
    fprintf(fp,"    for (jj = 0; jj < nterms; jj++) {\n");
    fprintf(fp,"      dtmp = 0.0;\n");
    fprintf(fp,"      for (kk = 0; kk < nterms; kk++)\n");
    fprintf(fp,"        dtmp += invCovMat[jj][kk] * u[kk];\n");
    fprintf(fp,"      std += dtmp * u[jj];\n");
    fprintf(fp,"    }\n");
    fprintf(fp,"    std = sqrt(std);\n");
    fprintf(fp,"    S[ii] = std;\n");
    fprintf(fp,"  }\n");
    fprintf(fp,"  free(u);\n");
    fprintf(fp,"  free(x);\n");
    fprintf(fp,"  return 0;\n");
    fprintf(fp,"}\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"/* Put your function definition here.        */\n");
    fprintf(fp,"/* ==========================================*/\n");
    fprintf(fp,"int func(int nInps, double *X, double *Y){\n");
    fprintf(fp,"  Y[0] = X[0] * X[0];\n");
    fprintf(fp,"  Y[1] = X[1] * X[1];\n");
    fprintf(fp,"  return 0;\n");
    fprintf(fp,"}\n");
    fprintf(fp,"/* ==============================================*/\n");
    fclose(fp);
    printf("FILE psuade_rs.info contains the user regression interpolator\n");
  }
  fp = NULL;
  if (psRSCodeGen_ == 1) fp = fopen("psuade_rs.py", "w");
  if (fp != NULL)
  {
    fprintf(fp,"#!/usr/bin/python\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# Response surface interpolator from PSUADE\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"# This file contains information for interpolation\n");
    fprintf(fp,"# using response surface. Follow the steps below:\n");
    fprintf(fp,"#  1. move this file to *.py file (e.g. interpolate.py)\n");
    fprintf(fp,"#  2. modify 'func' to reflect your basis functions.\n");
    fprintf(fp,"#  3. make sure the first line points to your Python\n");
    fprintf(fp,"#  4. prepare your new sample points to be interpolated\n");
    fprintf(fp,"#     in a text file (e.g. infile) with the format below:\n");
    fprintf(fp,"#    <number of sample points M> <number of inputs n>\n");
    fprintf(fp,"#    1 input1 input2 ...inputn\n");
    fprintf(fp,"#    2 input1 input2 ...inputn\n");
    fprintf(fp,"#    ....\n");
    fprintf(fp,"#    M input1 input2 ...inputn\n");
    fprintf(fp,"#  5. run: interpolate.py infile outfile\n");
    fprintf(fp,"#     where <outfile> will have the interpolated values.\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"import sys\n");
    fprintf(fp,"import string\n");
    fprintf(fp,"import math\n\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"# User regressioin interpolation\n");
    fprintf(fp,"#==================================================\n");
    fwriteRSPythonCommon(fp);
    fprintf(fp,"regCoefs = [\n");
    for (mm = 0; mm < N-1; mm++)
      fprintf(fp," %24.16e,\n", regCoeffs_[mm]);
    fprintf(fp," %24.16e ]\n", regCoeffs_[N-1]);
    fprintf(fp,"XStat = [\n");
    for (mm = 0; mm < nInputs_; mm++)
      fprintf(fp,"  [ %24.16e , %24.16e ],\n",XNShift_[mm],XNScale_[mm]);
    fprintf(fp,"]\n");
    fprintf(fp,"invCovMat = [\n");
    for (mm = 0; mm < N; mm++)
    {
      fprintf(fp," [ %24.16e", invCovMat_.getEntry(mm,0));
      for (nn = 1; nn < N; nn++)
        fprintf(fp,", %24.16e", invCovMat_.getEntry(mm,nn));
      fprintf(fp," ]\n");
    }
    fprintf(fp,"]\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# define your function here \n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"def func(X) : \n");
    fprintf(fp,"  nn = len(X)\n");
    fprintf(fp,"  mm = %d\n", numTerms_);
    fprintf(fp,"  U  = mm * [0.0]\n");
    fprintf(fp,"  for ii in range(mm): \n");
    fprintf(fp,"#    fill in your ii-th basis function\n");
    fprintf(fp,"#    U[ii] = evalBasisFcn(ii,X)\n");
    fprintf(fp,"  return U\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# Regression interpolation function  \n");
    fprintf(fp,"# X[0], X[1],   .. X[m-1]   - first point\n");
    fprintf(fp,"# X[m], X[m+1], .. X[2*m-1] - second point\n");
    fprintf(fp,"# ... \n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"def interpolate(X): \n");
    fprintf(fp,"  nSamp = int(len(X) / %d)\n", nInputs_);
    fprintf(fp,"  Xt = %d * [0.0]\n", nInputs_);
    fprintf(fp,"  Ys = 2 * nSamp * [0.0]\n");
    fprintf(fp,"  for ss in range(nSamp) : \n");
    fprintf(fp,"    for ii in range(%d) : \n", nInputs_);
    fprintf(fp,"      Xt[ii] = (X[ss*%d+ii]-XStat[ii][0])/XStat[ii][1]\n",
            nInputs_);
    fprintf(fp,"    U = func(Xt)\n");
    fprintf(fp,"    Y = 0.0\n");
    fprintf(fp,"    for jj in range(%d) : \n", numTerms_);
    fprintf(fp,"      Y += regCoefs[jj] * U[jj]\n");
    fprintf(fp,"    Ys[2*ss] = Y * %e + %e;\n", YStd_, YMean_);
    fprintf(fp,"    std = 0.0;\n");
    fprintf(fp,"    for jj in range(%d): \n", numTerms_);
    fprintf(fp,"      dtmp = 0.0\n");
    fprintf(fp,"      for kk in range(%d): \n", numTerms_);
    fprintf(fp,"        dtmp = dtmp + invCovMat[jj][kk] * U[kk]\n");
    fprintf(fp,"      std = std + dtmp * U[jj]\n");
    fprintf(fp,"    Ys[2*ss+1] = math.sqrt(std)\n");
    fprintf(fp,"  return Ys\n");
    fprintf(fp,"###################################################\n");
    fprintf(fp,"# main program\n");
    fprintf(fp,"#==================================================\n");
    fprintf(fp,"infileName  = sys.argv[1]\n");
    fprintf(fp,"outfileName = sys.argv[2]\n");
    fprintf(fp,"inputs = getInputData(infileName)\n");
    fprintf(fp,"outputs = interpolate(inputs)\n");
    fprintf(fp,"genOutputFile(outfileName, outputs)\n");
    fprintf(fp,"###################################################\n");
    fclose(fp);
    printf("FILE psuade_rs.py contains the user regression interpolator.\n");
  }
  return 0;
}

// *************************************************************************
// load the X matrix
// -------------------------------------------------------------------------
int UserRegression::loadXMatrix(psVector VecX, psMatrix &MatXX)
{
  int    M, N, mm, kk;
  double *arrayXX;
  char   sysCmd[500], lineIn[5001];
  FILE   *fp;

  M = nSamples_;
  N = numTerms_;
  MatXX.setDim(M, N);
  arrayXX = MatXX.getMatrix1D();
  if (psPythonOverride_ == 0)
  {
    if (psPythonInterpreter_ != NULL)
    {
      if (numArgs_ == 2) 
           sprintf(sysCmd,"%s %s ps_input ps_output",
                   psPythonInterpreter_,regFile_);
      else sprintf(sysCmd,"%s %s ps_input ps_output %s",
                   psPythonInterpreter_,regFile_,auxArg_);
    }
    else
    {
      if (numArgs_ == 2) 
           sprintf(sysCmd,"python %s ps_input ps_output",regFile_);
      else sprintf(sysCmd,"python %s ps_input ps_output %s",
                   regFile_,auxArg_);
    }
  }
  else
  {
    if (numArgs_ == 2) 
         sprintf(sysCmd,"%s ps_input ps_output",regFile_);
    else sprintf(sysCmd,"%s ps_input ps_output %s",regFile_,auxArg_);
  }
  fp = fopen("ps_input", "w");
  if(fp == NULL)
  {
    printf("file 'ps_input' expected but not found.\n");
    printf("fopen returned NULL in file %s line %d, exiting\n",
           __FILE__, __LINE__);
    exit(1);
  }
  fprintf(fp, "%d %d\n", M, nInputs_);
  for (mm = 0; mm < M; mm++)
  {
    fprintf(fp, "%d", mm+1);
    for (kk = 0; kk < nInputs_; kk++)
      fprintf(fp, " %e", (VecX[mm*nInputs_+kk]-XNShift_[kk])*XNScale_[kk]);
    fprintf(fp, "\n");
  }
  fclose(fp);
  if (outputLevel_ > 1) printf("UserRegression run : %s\n",sysCmd);
  system(sysCmd);
  fp = fopen("ps_output", "r");
  if (fp == NULL)
  {
    printf("file 'ps_output' expected but not found.\n");
    printf("fopen returned NULL in file %s line %d, exiting\n", 
            __FILE__, __LINE__);
    exit(1);
  }
  for (mm = 0; mm < M; mm++)
  {
    if (mm == 0)
    {
      fscanf(fp, "%s", lineIn); 
      if (lineIn[0] == '#')
      {
        fgets(lineIn, 5000, fp);
        fscanf(fp, "%d", &kk);
      }
      else sscanf(lineIn, "%d", &kk);
    }
    else fscanf(fp, "%d", &kk);
    if (kk != mm+1)
    {
      printf("ERROR: user output file does not have correct format.\n");
      printf("  Expected index = %d, actual index = %d\n",mm+1,kk);
      fclose(fp);
      exit(1);
    }
    for (kk = 0; kk < N; kk++) fscanf(fp, "%lg", &arrayXX[M*kk+mm]);
    if ((fgets(lineIn, 5000, fp) == NULL) && (mm < M-1))
    {
      printf("ERROR: user output file does not have enough data (%d).\n",
             mm);
      printf("    => %s\n",lineIn);
      fclose(fp);
      exit(1);
    }
  }
  fclose(fp);
  unlink("ps_input");
  unlink("ps_output");
  return N;
}

// *************************************************************************
// compute SS (sum of squares) statistics
// -------------------------------------------------------------------------
int UserRegression::computeSS(psMatrix MatXX, psVector VecY, psVector VecB,
                              double &SSresid, double &SStotal)
{
  int    nn, mm, N;
  double rdata, ymean, SSreg, ddata, SSresidCheck, *arrayXX;
                                                                                
  N = VecB.length();
  arrayXX = MatXX.getMatrix1D();
  SSresid = SSresidCheck = SStotal = SSreg = ymean = 0.0;
  for (mm = 0; mm < nSamples_; mm++)
    ymean += (sqrt(weights_[mm]) * VecY[mm]);
  ymean /= (double) nSamples_;
  for (mm = 0; mm < nSamples_; mm++)
  {
    ddata = 0.0;
    for (nn = 0; nn < N; nn++) ddata += (arrayXX[mm+nn*nSamples_]*VecB[nn]);
    rdata = VecY[mm] - ddata;
    SSresid += VecY[mm] * rdata * weights_[mm];
    SSresidCheck += rdata * rdata * weights_[mm];
    SSreg += (ddata - ymean) * (ddata - ymean);
  }
  for (mm = 0; mm < nSamples_; mm++)
    SStotal += weights_[mm] * (VecY[mm] - ymean) * (VecY[mm] - ymean);
  if (outputLevel_ > 0)
  {
    printf("* UserRegression: SStot  = %24.16e\n", SStotal);
    printf("* UserRegression: SSreg  = %24.16e\n", SSreg);
    printf("* UserRegression: SSres  = %24.16e\n", SSresid);
    printf("* UserRegression: SSres  = %24.16e (true)\n", SSresidCheck);
  }
  SSresid = SSresidCheck;
  if (outputLevel_ > 0 && nSamples_ != N)
  {
    printf("* UserRegression: eps(Y) = %24.16e\n",
           SSresidCheck/(nSamples_-N));
  }
  return 0;
}

// *************************************************************************
// compute coefficient variance ((diagonal of sigma^2 (X' X)^(-1))
// -------------------------------------------------------------------------
int UserRegression::computeCoeffVariance(psMatrix &eigMatT, 
                                         psVector &eigVals, double var)
{
  int      ii, jj, nRows;
  double   invEig, dtmp;
  psMatrix tMat;

  nRows = eigMatT.nrows();
  tMat.setDim(nRows, nRows);

  for (ii = 0; ii < nRows; ii++)
  {
    invEig = eigVals[ii];
    if (invEig != 0.0) invEig = 1.0 / invEig;
    for (jj = 0; jj < nRows; jj++)
    {
      dtmp = invEig * eigMatT.getEntry(ii,jj) * var;
      tMat.setEntry(jj, ii, dtmp);
    }
  }
  eigMatT.matmult(tMat, invCovMat_);
  if (psMasterMode_ == 1)
  {
    printf("invCovMat = \n");
    invCovMat_.print();
  }
  return 0;
}

// ************************************************************************
// print statistics
// ------------------------------------------------------------------------
int UserRegression::printRC(psVector VecB,psVector VecBstd,psMatrix,
                            psVector VecY)
{
  int    ii;
  double coef;

  printDashes(PL_INFO, 0);
  printf("*  Term    coefficient     std. error     t-value\n");
  for (ii = 0; ii < numTerms_; ii++)
  {
    if (PABS(VecBstd[ii]) < 1.0e-15) coef = 0.0;
    else                             coef = VecB[ii] / VecBstd[ii]; 
    printf("*   %3d   %12.4e   %12.4e   %12.4e\n",ii+1,VecB[ii],
           VecBstd[ii],coef);
  }
  printDashes(PL_INFO, 0);
  return 0;
}

// ************************************************************************
// set parameters
// ------------------------------------------------------------------------
double UserRegression::setParams(int targc, char **targv)
{
  struct stat sb;
  FILE   *fp;
  if (targc > 0 && !strcmp(targv[0], "set_user_script"))
  {
    if (targc < 2)
    {
      printf("UserRegression ERROR: setParam - in setting user_script\n");
      exit(1);
    }
    strncpy(regFile_, targv[1], 1000);
    fp = fopen(regFile_, "r");
    if (fp == NULL)
    {
      printf("UserRegression ERROR: user executable %s not found.\n",
             regFile_);
      exit(1);
    }
    fclose(fp);
    if (stat(regFile_, &sb) != 0 || !(sb.st_mode & S_IXUSR))
    {
      printf("UserRegression WARNING : User-provided executable does\n");
      printf("                         not have execute permission.\n");
      exit(1);
    }
  }
  else if (targc == 2 && !strcmp(targv[0], "set_aux_arg"))
  {
     strcpy(auxArg_, targv[1]);
  }
  return 0.0;
}

